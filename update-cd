#!/bin/bash
#
# $Id$
# 
# (c) Steve McIntyre <stevem@chiark.greenend.org.uk> Released under
# GNU GPL v2 1st January 2001
#
# Quick and dirty script to create update CDs for people to upgrade
# from an initial stable release (r0) to the latest point release level
#

set -e

# Configuration goes here.

# Where is your mirror?
MIRROR_NORM=/org/cdbuilder.debian.org/src/ftp/debian
MIRROR_AMD64=/org/cdbuilder.debian.org/src/ftp/debian-amd64/debian

# Do you want non-free? 1 for yes, 0 for no
NONFREE=0

# What release version is this?
VER=6.0.1a

# Is this an official CD?
OFFICIAL=Official
# OFFICIAL="Unofficial snapshot"

# Path to use with mkisofs/mkhybrid
MKISOFS="$PWD/../genisoimage -jigdo-template-compress bzip2 -r -checksum_algorithm_iso md5,sha1,sha256,sha512"

# Use JTE extensions to mkisofs to make jigdo files?
JTE=1

# The working directory to use. MUST be on the same partition as the mirror.
TDIR=/org/cdbuilder.debian.org/src/deb-cd/tmp/squeeze-update/cd-work

# Building squeeze cd set ...
CODENAME=squeeze

# Path where the images will be written
OUT=/org/cdbuilder.debian.org/src/deb-cd/tmp/squeeze-update/cd-out

# Location(s) for the snapshot(s)
SNAPSHOT='Debian=http://us.cdimage.debian.org/cdimage/snapshot/Debian/ --try-last'

# Type of disc image, cd or dvd (lower case)
if [ "$1"x = ""x ] ; then
    TYPE=cd
else
    TYPE=$1
fi
case $TYPE in
    cd|CD)
	TYPE=cd
	TYPEUP=CD;;
    dvd|DVD)
	TYPE=dvd
	TYPEUP=DVD;;
    *)
	echo "Specify a disk type..."
	exit 1;;
esac

# Location of the diff file to use to determine the changes. If you leave
# this blank, we'll try to determine the changes from the ChangeLog files,
# which is probably less accurate. 
DIFF=/home/debian-cd/lists/squeeze/r0-r1.diff

if [ "$TYPE" = "cd" ] ; then
    CDSIZE=644 # megabytes, leaving space for metadata
else
    CDSIZE=4300 # megabytes, leaving space for metadata
fi

REL=Debian"$VER"
CLOG=dists/$CODENAME/ChangeLog
UPD=$TDIR/$CODENAME-update
DATE=`date +%Y%m%d`
BASEDIR=`pwd`
SECTS="main non-free contrib"
VERBOSE=2
GRAB_MD5=$BASEDIR/tools/grab_md5
export VERBOSE BASEDIR SECTS

FIRSTVER=`echo $VER | cut -c 1-4`0
CAPCODE=`perl -e "print ucfirst("$CODENAME")"`

export FIRSTVER CAPCODE

if [ "$ARCHLIST"x = ""x ] ; then
    ARCHLIST="armel amd64 i386 ia64 mips mipsel powerpc s390 sparc source kfreebsd-amd64 kfreebsd-i386" # amd64 # all dealt with specially
fi

export TDIR NONFREE VER MIRROR CODENAME OUT BASEDIR

CDSIZE=$(($CDSIZE * 1024))

create_control=$BASEDIR/tools/create_control
set_mkisofs_opts=$BASEDIR/tools/set_mkisofs_opts
addfiles=$BASEDIR/tools/add_files

copy_file () {
    ROOTDIR=$1
    shift
    FILE=$1
    DIR=`dirname $FILE`
    if [ ! -d $ROOTDIR/$DIR ] ; then
        mkdir -p $ROOTDIR/$DIR
    fi
    if [ -e $MIRROR/$FILE ] ; then
	cp -l $MIRROR/$FILE $ROOTDIR/$FILE
    else
	echo
	echo "File $FILE not found!"
	exit 1
    fi
}

make_cd () {
    CDNUM=$1
    shift
    THISNUM=$1
    shift
    THISARCH=$1
    shift
    SRCFILES=$1
    shift
    ARCHFILES=$1
    shift
    ALLFILES=$1
    echo
    echo "  Creating Packages and Sources files for CD$CDNUM"
    cd $UPD
    $create_control CD$CDNUM $THISARCH
    echo "  Creating image for CD$CDNUM ($SRCFILES source files, $ARCHFILES $ARCH debs, $ALLFILES all debs)"
    echo -n "    "
    if [ ! -d $OUT/$THISARCH/iso-$TYPE ] ; then
	mkdir -p $OUT/$THISARCH/iso-$TYPE
    fi
    if [ $JTE = 1 ] ; then
	if [ ! -d $OUT/$THISARCH/jigdo-$TYPE ] ; then
	    mkdir -p $OUT/$THISARCH/jigdo-$TYPE
	fi
    if [ ! -d $OUT/$THISARCH/list-$TYPE ] ; then
       mkdir -p $OUT/$THISARCH/list-$TYPE
    fi

	${MKISOFS} -J -r -V "Debian $VER update $TYPEUP" -o \
	    $OUT/$THISARCH/iso-$TYPE/debian-update-$VER-$THISARCH-$TYPEUP-$THISNUM.iso \
	    -jigdo-jigdo $OUT/$THISARCH/jigdo-$TYPE/debian-update-$VER-$THISARCH-$TYPEUP-$THISNUM.jigdo \
	    -jigdo-template $OUT/$THISARCH/jigdo-$TYPE/debian-update-$VER-$THISARCH-$TYPEUP-$THISNUM.template \
	    -jigdo-map Debian=$MIRROR/ \
	    -jigdo-force-md5 /pool/ \
	    -md5-list $UPD/md5-check \
	    $UPD/CD$CDNUM 2>&1 | grep "extents written"
	$BASEDIR/tools/jigdo_cleanup \
	    $OUT/$THISARCH/jigdo-$TYPE/debian-update-$VER-$THISARCH-$TYPEUP-$THISNUM.jigdo \
	    debian-update-$VER-$THISARCH-$TYPEUP-$THISNUM.iso \
	    $OUT debian-update-$VER-$THISARCH-$TYPEUP-$THISNUM.template \
	    "Debian GNU/Linux $VER - $OFFICIAL $THISARCH $FIRSTVER->$VER update $TYPEUP #$THISNUM"
	echo $SNAPSHOT >> $OUT/$THISARCH/jigdo-$TYPE/debian-update-$VER-$THISARCH-$TYPEUP-$THISNUM.jigdo
	    # Make sure that the ISO is as new/newer than the jigdo file; #587774
        touch $OUT/$THISARCH/iso-$TYPE/debian-update-$VER-$THISARCH-$TYPEUP-$THISNUM.iso

        MD5=`cat $OUT/$THISARCH/jigdo-$TYPE/debian-update-$VER-$THISARCH-$TYPEUP-$THISNUM.jigdo | \
	    awk '/Image Hex MD5Sum/ {print $5}'`
        echo "$MD5  debian-update-$VER-$THISARCH-$TYPEUP-$THISNUM.iso" >> $OUT/$THISARCH/jigdo-$TYPE/MD5SUMS.update
        echo "$MD5  debian-update-$VER-$THISARCH-$TYPEUP-$THISNUM.iso" >> $OUT/$THISARCH/iso-$TYPE/MD5SUMS.update
	for SHA_SIZE in 1 256 512; do
	    SHA=`cat $OUT/$THISARCH/jigdo-$TYPE/debian-update-$VER-$THISARCH-$TYPEUP-$THISNUM.jigdo | \
		awk "/Image Hex SHA${SHA_SIZE}Sum/ {print \\$5}"`
	    if [ "$SHA"x = ""x ] ; then
		echo "SHA fail"
		exit 1
	    fi
	    echo "$SHA  debian-update-$VER-$THISARCH-$TYPEUP-$THISNUM.iso" >> $OUT/$THISARCH/jigdo-$TYPE/SHA${SHA_SIZE}SUMS.update
	    echo "$SHA  debian-update-$VER-$THISARCH-$TYPEUP-$THISNUM.iso" >> $OUT/$THISARCH/iso-$TYPE/SHA${SHA_SIZE}SUMS.update
	done
	gzip -9 $OUT/$THISARCH/jigdo-$TYPE/debian-update-$VER-$THISARCH-$TYPEUP-$THISNUM.jigdo
	mv $OUT/$THISARCH/jigdo-$TYPE/debian-update-$VER-$THISARCH-$TYPEUP-$THISNUM.jigdo.gz \
	    $OUT/$THISARCH/jigdo-$TYPE/debian-update-$VER-$THISARCH-$TYPEUP-$THISNUM.jigdo
    else
	${MKISOFS} -J -r -V "Debian $VER update $TYPEUP" -o \
	    $OUT/iso-$TYPE/$CODENAME-update-$THISARCH-$TYPEUP-$THISNUM.iso \
	    $UPD/CD$CDNUM 2>&1 | grep "extents written"
    fi
    find $UPD/CD$CDNUM/pool -type f | sed 's?^.*/??g' | gzip -9 > $OUT/$THISARCH/list-$TYPE/debian-update-$VER-$THISARCH-$TYPEUP-$THISNUM.list.gz
}

add_file () {
    file=$1
    case "$THISARCH" in
	source)
	    case "$file" in
		*.gz|*.bz2|*.dsc)
		    copy_file $UPD/CD$CDNUM $file
		    SRCFILES=$(($SRCFILES + 1))
		    ;;
	    esac
	    echo -en "\r$SRCFILES copied"
	    ;;
	*)
	    case "$file" in
		*_$THISARCH.deb)
                    copy_file $UPD/CD$CDNUM $file
		    ARCHFILES=$(($ARCHFILES + 1))
		    ;;
                *_all.deb)
	            copy_file $UPD/CD$CDNUM $file
		    ALLFILES=$(($ALLFILES + 1))
		    ;;
	    esac
	    echo -en "\r$THISARCH:$ARCHFILES all:$ALLFILES copied"
	    ;;
    esac
}

echo Cleaning up
rm -rf $UPD
mkdir -p $UPD
CDNUM=1

echo Creating file list

if [ ! -e $DIFF ] ; then
    echo "NO DIFF FOUND. ABORT!"
    exit 1
fi

cp $DIFF $UPD/list
if [ "$NONFREE"x != "1"x ] ; then
    echo "Removing non-free files from the list"
    grep -v non-free $UPD/list > $UPD/list1
    mv -f $UPD/list1 $UPD/list
fi

$GRAB_MD5 $MIRROR_NORM "$ARCHLIST" $CODENAME $CODENAME $UPD/md5-check

for THISARCH in $ARCHLIST
do
    THISNUM=0

    MIRROR=$MIRROR_NORM

    rm -rf $OUT/$THISARCH/iso-$TYPE $OUT/$THISARCH/jigdo-$TYPE

    for file in `cat $UPD/list`
    do
	if [ ! -d $UPD/CD$CDNUM ] ; then
	    echo
	    cd $MIRROR
	    THISNUM=$((THISNUM + 1))
	    if [ $THISARCH = "source" ] ; then
		echo "Creating $TYPEUP$CDNUM for source (part $THISNUM)"
	    else
		echo "Creating $TYPEUP$CDNUM for binary-$THISARCH (part $THISNUM)"
	    fi
	    mkdir $UPD/CD$CDNUM $UPD/CD$CDNUM/.disk
	    INFO="Debian GNU/Linux $VER Update $TYPEUP $DATE: $THISARCH $TYPEUP $THISNUM"
	    echo $INFO > $UPD/CD$CDNUM/.disk/info
	    SIZE_USED=0
	    SRCFILES=0
	    ARCHFILES=0
	    ALLFILES=0
	fi	

	if [ "$BACKOUT_FILE"x != ""x ] ; then
	    echo "Starting with backed-out file $BACKOUT_FILE"
	    add_file $BACKOUT_FILE
	    BACKOUT_FILE=""
	fi

	add_file $file

	SIZE_USED=`du -sk $UPD/CD$CDNUM | awk '{print $1}'`
	if [ $SIZE_USED -gt $CDSIZE ] ; then
	    # Back out the last file added
	    size=`stat -c %s $UPD/CD$CDNUM/$file`
	    rm -f $UPD/CD$CDNUM/$file
	    echo 
	    echo "  Overfull: back out $file ($size bytes)"
	    DIR=`dirname $file`
	    rmdir $DIR > /dev/null 2>&1 || true
	    BACKOUT_FILE=$file
	    make_cd $CDNUM $THISNUM $THISARCH $SRCFILES $ARCHFILES $ALLFILES
	    CDNUM=$(($CDNUM + 1))
	    continue
	fi
    done

    make_cd $CDNUM $THISNUM $THISARCH $SRCFILES $ARCHFILES $ALLFILES
    CDNUM=$(($CDNUM + 1))
done

